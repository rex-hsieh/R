---
title: "Introduction to R: Codes and Examples"
author: Meng Hsuan Hsieh
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. You are not expected to write this from the grounds up; this is created purely for demonstration purposes, so you can follow some of teh commands that you've been asked to do.

The following is a quick tutorial, should you ever want to use Markdown documents in the near future.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter* (when you're in an IDE). 

```{r}
plot(cars, main="Distance vs Speed of Cars")
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


----
# The Basics

A copy of *Learning R* by Cotton (published by O'Reilly) is available in your Google Drive. I will follow its examples closely, while offering some methods that I found useful (and fairly efficient, of course).

## Declaring Objects

**Assigning variables** is an important part of any languages; for historical reasons, I prefer using "<-" to assign variables, though "=" works just as well.


```{r}
x <- 1:5
y = 6:10
x + 2 * y - 3
```

Variable names can contain letters, numbers, dots, and underscores, but they can't start with a number, or a dot followed by a number (since that looks too much like a number). Reserved words like "if " and "for" are not allowed. In some locales, non-ASCII letters are allowed, but for code portability it is better to stick to "a" to "z" (and "A" to "Z"). The help page ?make.names gives precise details about what is and isn't allowed.

We are not always interested in assigning **global variables**; for reasons that will be clear if you learn more general scripting languages such as Python, global variables make codes quite "stiff" and hard to alter. However, for the sake of completeness, one would declare it as follows:

```{r}
a <<- exp(exp(1))
assign("my_local_variable", 9 ^ 3 + 10 ^ 3)
assign("my_global_variable", 1 ^ 3 + 12 ^ 3, globalenv())
```

There are at least two remarks we can make here:

1. assign() function does exactly what it is supposed to. The extra globalenv() argument is required for making <<- declarations.
2. The distinction between local and global variables is more generally referred to as **scoping**. This would be covered in more details if we have the time to, but scopes, along with **namescapes**, are legitimate concerns for maintaining code in the future.


## Special Numbers
These are to watch out for when we get into cleaning datasets.

```{r}
c(Inf + 1, Inf - 1, Inf - Inf)
c(1 / Inf, Inf / 1, Inf / Inf)
c(sqrt(Inf), sin(Inf))
c(log(Inf), log(Inf, base = Inf))
c(NA + 1, NA * 5, NA + Inf)
```

One can easily identify these special numbers in datasetes by using the following commands:

```{r}
x <- c(0, Inf, -Inf, NaN, NA)
is.finite(x)
is.infinite(x)
is.nan(x)
is.na(x)
```

## Logic Notations

There are three vectorised logical operators in R:

* ! is used for not.
* & is used for and.
* | is used for or.

By *vectorised*, there are at least three common usage; in descending order of usage frequency:

1. An operator or a function that acts on each element of a vector without the need for you to explicitly write a loop (this built-in implicit looping over elements is also much faster than explicitly writing your own loop).
2. When a function takes a vector as an input and calculates a summary statistic.
3. Applies vectorisation over arguments. This is when a function calculates a summary statistic from several of its input arguments. The *sum* function does this, but it is very unusual. *median* does not.

Defining a new $x$ and simultaneously applying a logic statement to a list gives:

```{r}
(x <- 1:10 >= 5)
(y <- 1:10 %% 2 == 0)
x & y
x | y
```

Can you parse what these commands mean, using the logic notations from above?

We can conjure up some **truth tables** to see how they work (don't worry if this code doesn't make sense yet; just concentrate on understanding why each value occurs in the truth table):

```{r}
x <- c(TRUE, FALSE, NA) #the three logical values
xy <- expand.grid(x = x, y = x) #get all combinations of x and y
within( #make the next assignments within xy
  xy,
  {
    and <- x & y
    or <- x | y
    not.y <- !y
    not.x <- !x
  }
)
```

