seq.int(0.1, 0.01, -0.01)
n <- 0
1:n
```
Now, the following commands are quite useful for some text-based applications:
```{r}
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
```
If you already know some coding, you should know that one can easily iterate over numeric list; for that, sometimes length functions are useful.
```{r}
poincare <- c(1, 0, 0, 0, 2, 0, 2, 0) #See http://oeis.org/A051629
length(poincare)
length(poincare) <- 3
poincare
```
A great feature of Râ€™s vectors is that each element can be given a name. Labelling the elements can often make your code much more readable. You can specify names when you create a vector in the form name = value. If the name of an element is a valid variable name, it doesnâ€™t need to be enclosed in quotes. You can name some elements of a vector
and leave others blank:
plot(cars, main="Distance vs Speed of Cars")
x <- 1:5
y = 6:10
x + 2 * y - 3
a <<- exp(exp(1))
assign("my_local_variable", 9 ^ 3 + 10 ^ 3)
assign("my_global_variable", 1 ^ 3 + 12 ^ 3, globalenv())
c(Inf + 1, Inf - 1, Inf - Inf)
c(1 / Inf, Inf / 1, Inf / Inf)
c(sqrt(Inf), sin(Inf))
c(log(Inf), log(Inf, base = Inf))
c(NA + 1, NA * 5, NA + Inf)
x <- c(0, Inf, -Inf, NaN, NA)
is.finite(x)
is.infinite(x)
is.nan(x)
is.na(x)
(x <- 1:10 >= 5)
(y <- 1:10 %% 2 == 0)
x & y
x | y
x <- c(TRUE, FALSE, NA) #the three logical values
xy <- expand.grid(x = x, y = x) #get all combinations of x and y
within( #make the next assignments within xy
xy,
{
and <- x & y
or <- x | y
not.y <- !y
not.x <- !x
}
)
class(sqrt(1:10))
class(3 + 1i) #"i" creates imaginary components of complex numbers
class(1) #although this is a whole number, it has class numeric
class(1L) #add a suffix of "L" to make the number an integer
class(0.5:4.5) #the colon operator returns a value that is numeric...
class(1:5) #unless all its values are whole numbers
class(c("she", "sells", "seashells", "on", "the", "sea", "shore"))
(gender <- factor(c("male", "female", "female", "male", "female")))
levels(gender)
nlevels(gender)
if(!is(x, "some_class"))
{
#some corrective measure
}
is.character("red lorry, yellow lorry")
is.logical(FALSE)
is.list(list(a = 1, b = 2))
ls(pattern = "^is", baseenv())
is.numeric(1)
is.numeric(1L)
is.integer(1)
is.integer(1L)
is.double(1)
is.double(1L)
x <- "123.456"
as(x, "numeric")
as.numeric(x)
y <- c(2, 12, 343, 34997) #See http://oeis.org/A192892
as.data.frame(y)
ulams_spiral <- c(1, 8, 23, 46, 77) #See http://oeis.org/A033951
for(i in ulams_spiral) print(i)
print(ulams_spiral)
seq.int(3, 12)
seq.int(3, 12, 2)
seq.int(0.1, 0.01, -0.01)
n <- 0
1:n
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
poincare <- c(1, 0, 0, 0, 2, 0, 2, 0) #See http://oeis.org/A051629
length(poincare)
length(poincare) <- 3
poincare
plot(cars, main="Distance vs Speed of Cars")
c(apple = 1, banana = 2, "kiwi fruit" = 3, 4)
x <- 1:4
names(x) <- c("apple", "bananas", "kiwi fruit", "")
x
names(x)
c(apple = 1, banana = 2, "kiwi fruit" = 3, 4)
x <- 1:4
names(x) <- c("apple", "bananas", "kiwi fruit", "")
x
names(x)
x <- (1:5) ^ 2
x <- (1:5) ^ 2
x <- (1:5) ^ 2
x[c(1, 3, 5)]
x[c(-2, -4)]
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
names(x) <- c("one", "four", "nine", "sixteen", "twenty five")
x[c("one", "nine", "twenty five")]
rep.int(1:5, 3) # the same as rep(1:5, 3)
rep(1:5, 3)
rep(1:5, each = 3)
rep(1:5, times = 1:5)
rep(1:5, length.out = 7)
plot(cars, main="Distance vs Speed of Cars")
plot(cars, main="Distance vs Speed of Cars")
```{r, results="hide"}
plot(cars, main="Distance vs Speed of Cars")
(three_d_array <- array(
1:24,
dim = c(4, 3, 2),
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei"),
c("un", "deux")
)
))
(a_matrix <- matrix(
1:12,
nrow = 4, #ncol = 3 works the same
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei")
)
))
---
title: "Introduction to R: Codes and Examples"
author: Meng Hsuan Hsieh
output:
html_notebook:
theme: united
toc: yes
---
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. You are not expected to write this from the grounds up; this is created purely for demonstration purposes, so you can follow some of teh commands that you've been asked to do.
The following is a quick tutorial, should you ever want to use Markdown documents in the near future.
Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter* (when you're in an IDE).
```{r results="hide"}
plot(cars, main="Distance vs Speed of Cars")
```
Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.
When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).
The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
----
# The Basics
A copy of *Learning R* by Cotton (published by O'Reilly) is available in your Google Drive. I will follow its examples closely, while offering some methods that I found useful (and fairly efficient, of course).
## Declaring Objects
**Assigning variables** is an important part of any languages; for historical reasons, I prefer using "<-" to assign variables, though "=" works just as well.
```{r}
x <- 1:5
y = 6:10
x + 2 * y - 3
```
Variable names can contain letters, numbers, dots, and underscores, but they can't start with a number, or a dot followed by a number (since that looks too much like a number). Reserved words like "if " and "for" are not allowed. In some locales, non-ASCII letters are allowed, but for code portability it is better to stick to "a" to "z" (and "A" to "Z"). The help page ?make.names gives precise details about what is and isn't allowed.
We are not always interested in assigning **global variables**; for reasons that will be clear if you learn more general scripting languages such as Python, global variables make codes quite "stiff" and hard to alter. However, for the sake of completeness, one would declare it as follows:
```{r}
a <<- exp(exp(1))
assign("my_local_variable", 9 ^ 3 + 10 ^ 3)
assign("my_global_variable", 1 ^ 3 + 12 ^ 3, globalenv())
```
There are at least two remarks we can make here:
1. assign() function does exactly what it is supposed to. The extra globalenv() argument is required for making <<- declarations.
2. The distinction between local and global variables is more generally referred to as **scoping**. This would be covered in more details if we have the time to, but scopes, along with **namescapes**, are legitimate concerns for maintaining code in the future.
## Special Numbers
These are to watch out for when we get into cleaning datasets.
```{r}
c(Inf + 1, Inf - 1, Inf - Inf)
c(1 / Inf, Inf / 1, Inf / Inf)
c(sqrt(Inf), sin(Inf))
c(log(Inf), log(Inf, base = Inf))
c(NA + 1, NA * 5, NA + Inf)
```
One can easily identify these special numbers in datasetes by using the following commands:
```{r}
x <- c(0, Inf, -Inf, NaN, NA)
is.finite(x)
is.infinite(x)
is.nan(x)
is.na(x)
```
## Logic Notations
There are three vectorised logical operators in R:
* ! is used for not.
* & is used for and.
* | is used for or.
By *vectorised*, there are at least three common usage; in descending order of usage frequency:
1. An operator or a function that acts on each element of a vector without the need for you to explicitly write a loop (this built-in implicit looping over elements is also much faster than explicitly writing your own loop).
2. When a function takes a vector as an input and calculates a summary statistic.
3. Applies vectorisation over arguments. This is when a function calculates a summary statistic from several of its input arguments. The *sum* function does this, but it is very unusual. *median* does not.
Defining a new $x$ and simultaneously applying a logic statement to a list gives:
```{r}
(x <- 1:10 >= 5)
(y <- 1:10 %% 2 == 0)
x & y
x | y
```
Can you parse what these commands mean, using the logic notations from above?
We can conjure up some **truth tables** to see how they work (don't worry if this code doesn't make sense yet; just concentrate on understanding why each value occurs in the truth table):
```{r}
x <- c(TRUE, FALSE, NA) #the three logical values
xy <- expand.grid(x = x, y = x) #get all combinations of x and y
within( #make the next assignments within xy
xy,
{
and <- x & y
or <- x | y
not.y <- !y
not.x <- !x
}
)
```
The most important takewaway: logic in R is truly quite powerful. We will make use of them when we are cleaning datasets.
## Different Types of Numbers
One can differentiate between different types of numbers by knowing what classes they belong to:
```{r}
class(sqrt(1:10))
class(3 + 1i) #"i" creates imaginary components of complex numbers
class(1) #although this is a whole number, it has class numeric
class(1L) #add a suffix of "L" to make the number an integer
class(0.5:4.5) #the colon operator returns a value that is numeric...
class(1:5) #unless all its values are whole numbers
```
There are other types of classes, too:
```{r}
class(c("she", "sells", "seashells", "on", "the", "sea", "shore"))
(gender <- factor(c("male", "female", "female", "male", "female")))
```
The *levels* sublayer allows us to search for objects in the class related to the level. These can be thought of labels confined to specifc *factors*; to see this in action,
```{r}
levels(gender)
nlevels(gender)
```
A lot of operations in R (and any language in general) are *class-specific*. It is possible to write a code to the effect of
```{r}
if(!is(x, "some_class"))
{
#some corrective measure
}
```
And it is possible to verify classes of objects by the use of *is.$^{\star}$* functions.
```{r}
is.character("red lorry, yellow lorry")
is.logical(FALSE)
is.list(list(a = 1, b = 2))
```
```{r}
ls(pattern = "^is", baseenv())
```
One small oddity is that *is.numeric* returns *TRUE* for integers as well as floating point values. If we want to test for only floating point numbers, then we must use *is.double*. However, this isn't usually necessary, as R is designed so that floating point and integer values can be used more or less interchangeably. In the following examples, note that adding an L suffix makes the number into an integer:
```{r}
is.numeric(1)
is.numeric(1L)
is.integer(1)
is.integer(1L)
is.double(1)
is.double(1L)
```
Sometimes we may wish to change the type of an object. This is called casting, and most *is$^{\star}$* functions have a corresponding *as$^{\star}$* function to achieve it. The specialized *as$^{\star}$* functions should be used over plain *as* when available, since they are usually more efficient, and often contain extra logic specific to that class. For example, when converting a string to a number, *as.numeric* is slightly more efficient than plain *as*, but
either can be used:
```{r}
x <- "123.456"
as(x, "numeric")
as.numeric(x)
```
A common data structure we will be dealing with in R is called **data frame**. It is sort of like a spreadsheet, but much more flexible and mutable than one would see in Excel.
```{r}
y <- c(2, 12, 343, 34997) #See http://oeis.org/A192892
as.data.frame(y)
```
The last remark to be made in this section is the idea of *for* loops with vectors: you can do nifty things like this.
```{r}
ulams_spiral <- c(1, 8, 23, 46, 77) #See http://oeis.org/A033951
for(i in ulams_spiral) print(i)
print(ulams_spiral)
```
Can you explain the differences between these two prints? What objects are resulted from these prints?
# Data Structures
As is the case with many codes, it is important to understand data structures and the operations associated with every single one of them.
## More on Vectors, Matrices, and Arrays
One can vectorise a set of elements by the *vector()* call. However, it is quite slow and not extremely useful. The smarter thing to do is, generally, to work with sequences. See the following commands:
```{r}
seq.int(3, 12)
seq.int(3, 12, 2)
seq.int(0.1, 0.01, -0.01)
n <- 0
1:n
```
Now, the following commands are quite useful for some text-based applications:
```{r}
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
```
If you already know some coding, you should know that one can easily iterate over numeric list; for that, sometimes length functions are useful.
```{r}
poincare <- c(1, 0, 0, 0, 2, 0, 2, 0) #See http://oeis.org/A051629
length(poincare)
length(poincare) <- 3
poincare
```
A great feature of R's vectors is that each element can be given a name. Labelling the elements can often make your code much more readable. You can specify names when you create a vector in the form name = value. If the name of an element is a valid variable name, it doesn't need to be enclosed in quotes. You can name some elements of a vector
and leave others blank:
```{r}
c(apple = 1, banana = 2, "kiwi fruit" = 3, 4)
x <- 1:4
names(x) <- c("apple", "bananas", "kiwi fruit", "")
x
```
And, as expected, one can call the names of these structures by means of the *names()* function:
```{r}
names(x)
```
We will see this later, but the idea of working with data structures directly (rather than fiddling around with individual pieces of codes) is to gain more flexibility. Think of this remark in the following manner: often times we may want to access only part of a vector, or perhaps an individual element. This is called **indexing** and is accomplished with square brackets, [] (some people also call it subsetting or subscripting or slicing; all these terms refer to the same thing). R has
a very flexible system that gives us several choices of index:
* Passing a vector of positive numbers returns the slice of the vector containing the elements at those locations. The first position is 1 (not 0, as in some other languages).
* Passing a vector of negative numbers returns the slice of the vector containing the elements everywhere except at those locations.
* Passing a logical vector returns the slice of the vector containing the elements where the index is TRUE.
* For named vectors, passing a character vector of names returns the slice of the vector containing the elements with those names.
Vector-valued functions act component-wise on a list of elements.
```{r}
x <- (1:5) ^ 2
x[c(1, 3, 5)]
x[c(-2, -4)]
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
```
And let us give these some names: for people who only want to read numbers written in English letters.
```{r}
names(x) <- c("one", "four", "nine", "sixteen", "twenty five")
x[c("one", "nine", "twenty five")]
```
Combining the $x$ defined above and the slicing method introduced in the previous lines, and **without** running this code, can you tell me the output?
```{r}
x[c(1, NA, 5)]
x[c(TRUE, FALSE, NA, FALSE, TRUE)]
```
We can always recycle the vectors that we've used for different purposes, and to this end, the *rep()* function is extremely useful.
```{r}
rep(1:5, 3)
rep(1:5, each = 3)
rep(1:5, times = 1:5)
rep(1:5, length.out = 7)
```
Like the *seq()* function, rep has a simpler and faster variant, *rep.int()*, for the most common case:
```{r}
rep.int(1:5, 3) # the same as rep(1:5, 3)
```
Recent versions of R (since v3.0.0) also have rep_len, paralleling seq_len, which lets us specify the length of the output vector: try running the command rep_len(1:5, 13) to see the larger point here.
## Arrays
We create arrays using the *array()* function:
```{r}
(three_d_array <- array(
1:24,
dim = c(4, 3, 2),
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei"),
c("un", "deux")
)
))
```
The syntax for creating matrices is similar, but rather than passing a dim argument, you specify the number of rows or the number of columns:
```{r}
(a_matrix <- matrix(
1:12,
nrow = 4,  #ncol = 3 works the same
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei")
)
))
```
plot(cars, main="Distance vs Speed of Cars")
x <- 1:5
y = 6:10
x + 2 * y - 3
a <<- exp(exp(1))
assign("my_local_variable", 9 ^ 3 + 10 ^ 3)
assign("my_global_variable", 1 ^ 3 + 12 ^ 3, globalenv())
c(Inf + 1, Inf - 1, Inf - Inf)
c(1 / Inf, Inf / 1, Inf / Inf)
c(sqrt(Inf), sin(Inf))
c(log(Inf), log(Inf, base = Inf))
c(NA + 1, NA * 5, NA + Inf)
x <- c(0, Inf, -Inf, NaN, NA)
is.finite(x)
is.infinite(x)
is.nan(x)
is.na(x)
(x <- 1:10 >= 5)
(y <- 1:10 %% 2 == 0)
x & y
x | y
x <- c(TRUE, FALSE, NA) #the three logical values
xy <- expand.grid(x = x, y = x) #get all combinations of x and y
within( #make the next assignments within xy
xy,
{
and <- x & y
or <- x | y
not.y <- !y
not.x <- !x
}
)
class(sqrt(1:10))
class(3 + 1i) #"i" creates imaginary components of complex numbers
class(1) #although this is a whole number, it has class numeric
class(1L) #add a suffix of "L" to make the number an integer
class(0.5:4.5) #the colon operator returns a value that is numeric...
class(1:5) #unless all its values are whole numbers
class(c("she", "sells", "seashells", "on", "the", "sea", "shore"))
(gender <- factor(c("male", "female", "female", "male", "female")))
levels(gender)
nlevels(gender)
if(!is(x, "some_class"))
{
#some corrective measure
}
is.character("red lorry, yellow lorry")
is.logical(FALSE)
is.list(list(a = 1, b = 2))
ls(pattern = "^is", baseenv())
is.numeric(1)
is.numeric(1L)
is.integer(1)
is.integer(1L)
is.double(1)
is.double(1L)
x <- "123.456"
as(x, "numeric")
as.numeric(x)
y <- c(2, 12, 343, 34997) #See http://oeis.org/A192892
as.data.frame(y)
ulams_spiral <- c(1, 8, 23, 46, 77) #See http://oeis.org/A033951
for(i in ulams_spiral) print(i)
print(ulams_spiral)
seq.int(3, 12)
seq.int(3, 12, 2)
seq.int(0.1, 0.01, -0.01)
n <- 0
1:n
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
poincare <- c(1, 0, 0, 0, 2, 0, 2, 0) #See http://oeis.org/A051629
length(poincare)
length(poincare) <- 3
poincare
c(apple = 1, banana = 2, "kiwi fruit" = 3, 4)
x <- 1:4
names(x) <- c("apple", "bananas", "kiwi fruit", "")
x
names(x)
x <- (1:5) ^ 2
x[c(1, 3, 5)]
x[c(-2, -4)]
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
names(x) <- c("one", "four", "nine", "sixteen", "twenty five")
x[c("one", "nine", "twenty five")]
x[c(1, NA, 5)]
x[c(TRUE, FALSE, NA, FALSE, TRUE)]
rep(1:5, 3)
rep(1:5, each = 3)
rep(1:5, times = 1:5)
rep(1:5, length.out = 7)
rep.int(1:5, 3) # the same as rep(1:5, 3)
(three_d_array <- array(
1:24,
dim = c(4, 3, 2),
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei"),
c("un", "deux")
)
))
(a_matrix <- matrix(
1:12,
nrow = 4,  #ncol = 3 works the same
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei")
)
))
dim(a_matrix)
dim(a_matrix)
nrow(a_matrix)
ncol(a_matrix)
colnames(a_matrix)
rownames(a_matrix)
colnames(a_matrix)
dimnames(a_matrix)
rownames(a_matrix)
colnames(a_matrix)
dimnames(a_matrix)
a_matrix[1,]
a_matrix[,"zwei"]
a_matrix[1,]
a_matrix[,"zwei"]
a_matrix[,c("zwei","drei")]
a_matrix[,c("zwei")]
a_matrix[1,]
a_matrix[,"zwei"]
a_matrix[,c("zwei","drei")]
