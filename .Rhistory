x <- c(0, Inf, -Inf, NaN, NA)
is.finite(x)
is.infinite(x)
is.nan(x)
is.na(x)
```
## Logic Notations
There are three vectorised logical operators in R:
* ! is used for not.
* & is used for and.
* | is used for or.
By *vectorised*, there are at least three common usage; in descending order of usage frequency:
1. An operator or a function that acts on each element of a vector without the need for you to explicitly write a loop (this built-in implicit looping over elements is also much faster than explicitly writing your own loop).
2. When a function takes a vector as an input and calculates a summary statistic.
3. Applies vectorisation over arguments. This is when a function calculates a summary statistic from several of its input arguments. The *sum* function does this, but it is very unusual. *median* does not.
Defining a new $x$ and simultaneously applying a logic statement to a list gives:
```{r}
(x <- 1:10 >= 5)
(y <- 1:10 %% 2 == 0)
x & y
x | y
```
Can you parse what these commands mean, using the logic notations from above?
We can conjure up some **truth tables** to see how they work (don't worry if this code doesn't make sense yet; just concentrate on understanding why each value occurs in the truth table):
```{r}
x <- c(TRUE, FALSE, NA) #the three logical values
xy <- expand.grid(x = x, y = x) #get all combinations of x and y
within( #make the next assignments within xy
xy,
{
and <- x & y
or <- x | y
not.y <- !y
not.x <- !x
}
)
```
The most important takewaway: logic in R is truly quite powerful. We will make use of them when we are cleaning datasets.
## Different Types of Numbers
One can differentiate between different types of numbers by knowing what classes they belong to:
```{r}
class(sqrt(1:10))
class(3 + 1i) #"i" creates imaginary components of complex numbers
class(1) #although this is a whole number, it has class numeric
class(1L) #add a suffix of "L" to make the number an integer
class(0.5:4.5) #the colon operator returns a value that is numeric...
class(1:5) #unless all its values are whole numbers
```
There are other types of classes, too:
```{r}
class(c("she", "sells", "seashells", "on", "the", "sea", "shore"))
(gender <- factor(c("male", "female", "female", "male", "female")))
```
The *levels* sublayer allows us to search for objects in the class related to the level. These can be thought of labels confined to specifc *factors*; to see this in action,
```{r}
levels(gender)
nlevels(gender)
```
A lot of operations in R (and any language in general) are *class-specific*. It is possible to write a code to the effect of
```{r}
if(!is(x, "some_class"))
{
#some corrective measure
}
```
And it is possible to verify classes of objects by the use of *is.$^{\star}$* functions.
```{r}
is.character("red lorry, yellow lorry")
is.logical(FALSE)
is.list(list(a = 1, b = 2))
```
```{r}
ls(pattern = "^is", baseenv())
```
One small oddity is that *is.numeric* returns *TRUE* for integers as well as floating point values. If we want to test for only floating point numbers, then we must use *is.double*. However, this isn't usually necessary, as R is designed so that floating point and integer values can be used more or less interchangeably. In the following examples, note that adding an L suffix makes the number into an integer:
```{r}
is.numeric(1)
is.numeric(1L)
is.integer(1)
is.integer(1L)
is.double(1)
is.double(1L)
```
Sometimes we may wish to change the type of an object. This is called casting, and most *is$^{\star}$* functions have a corresponding *as$^{\star}$* function to achieve it. The specialized *as$^{\star}$* functions should be used over plain *as* when available, since they are usually more efficient, and often contain extra logic specific to that class. For example, when converting a string to a number, *as.numeric* is slightly more efficient than plain *as*, but
either can be used:
```{r}
x <- "123.456"
as(x, "numeric")
as.numeric(x)
```
A common data structure we will be dealing with in R is called **data frame**. It is sort of like a spreadsheet, but much more flexible and mutable than one would see in Excel.
```{r}
y <- c(2, 12, 343, 34997) #See http://oeis.org/A192892
as.data.frame(y)
```
The last remark to be made in this section is the idea of *for* loops with vectors: you can do nifty things like this.
```{r}
ulams_spiral <- c(1, 8, 23, 46, 77) #See http://oeis.org/A033951
for(i in ulams_spiral) print(i)
print(ulams_spiral)
```
Can you explain the differences between these two prints? What objects are resulted from these prints?
# Data Structures
As is the case with many codes, it is important to understand data structures and the operations associated with every single one of them.
## More on Vectors, Matrices, and Arrays
One can vectorise a set of elements by the *vector()* call. However, it is quite slow and not extremely useful. The smarter thing to do is, generally, to work with sequences. See the following commands:
```{r}
seq.int(3, 12)
seq.int(3, 12, 2)
seq.int(0.1, 0.01, -0.01)
n <- 0
1:n
```
Now, the following commands are quite useful for some text-based applications:
```{r}
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
```
If you already know some coding, you should know that one can easily iterate over numeric list; for that, sometimes length functions are useful.
```{r}
poincare <- c(1, 0, 0, 0, 2, 0, 2, 0) #See http://oeis.org/A051629
length(poincare)
length(poincare) <- 3
poincare
```
A great feature of R's vectors is that each element can be given a name. Labelling the elements can often make your code much more readable. You can specify names when you create a vector in the form name = value. If the name of an element is a valid variable name, it doesn't need to be enclosed in quotes. You can name some elements of a vector
and leave others blank:
```{r}
c(apple = 1, banana = 2, "kiwi fruit" = 3, 4)
x <- 1:4
names(x) <- c("apple", "bananas", "kiwi fruit", "")
x
```
And, as expected, one can call the names of these structures by means of the *names()* function:
```{r}
names(x)
```
We will see this later, but the idea of working with data structures directly (rather than fiddling around with individual pieces of codes) is to gain more flexibility. Think of this remark in the following manner: often times we may want to access only part of a vector, or perhaps an individual element. This is called **indexing** and is accomplished with square brackets, [] (some people also call it subsetting or subscripting or slicing; all these terms refer to the same thing). R has
a very flexible system that gives us several choices of index:
* Passing a vector of positive numbers returns the slice of the vector containing the elements at those locations. The first position is 1 (not 0, as in some other languages).
* Passing a vector of negative numbers returns the slice of the vector containing the elements everywhere except at those locations.
* Passing a logical vector returns the slice of the vector containing the elements where the index is TRUE.
* For named vectors, passing a character vector of names returns the slice of the vector containing the elements with those names.
Vector-valued functions act component-wise on a list of elements.
```{r}
x <- (1:5) ^ 2
x[c(1, 3, 5)]
x[c(-2, -4)]
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
```
And let us give these some names: for people who only want to read numbers written in English letters.
```{r}
names(x) <- c("one", "four", "nine", "sixteen", "twenty five")
x[c("one", "nine", "twenty five")]
```
Combining the $x$ defined above and the slicing method introduced in the previous lines, and **without** running this code, can you tell me the output?
```{r}
x[c(1, NA, 5)]
x[c(TRUE, FALSE, NA, FALSE, TRUE)]
```
We can always recycle the vectors that we've used for different purposes, and to this end, the *rep()* function is extremely useful.
```{r}
rep(1:5, 3)
rep(1:5, each = 3)
rep(1:5, times = 1:5)
rep(1:5, length.out = 7)
```
Like the *seq()* function, rep has a simpler and faster variant, *rep.int()*, for the most common case:
```{r}
rep.int(1:5, 3) # the same as rep(1:5, 3)
```
Recent versions of R (since v3.0.0) also have rep_len, paralleling seq_len, which lets us specify the length of the output vector: try running the command rep_len(1:5, 13) to see the larger point here.
## Arrays
We create arrays using the *array()* function:
```{r}
(three_d_array <- array(
1:24,
dim = c(4, 3, 2),
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei"),
c("un", "deux")
)
))
```
The syntax for creating matrices is similar, but rather than passing a dim argument, you specify the number of rows or the number of columns:
```{r}
(a_matrix <- matrix(
1:12,
nrow = 4,  #ncol = 3 works the same
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei")
)
))
```
plot(cars, main="Distance vs Speed of Cars")
x <- 1:5
y = 6:10
x + 2 * y - 3
a <<- exp(exp(1))
assign("my_local_variable", 9 ^ 3 + 10 ^ 3)
assign("my_global_variable", 1 ^ 3 + 12 ^ 3, globalenv())
c(Inf + 1, Inf - 1, Inf - Inf)
c(1 / Inf, Inf / 1, Inf / Inf)
c(sqrt(Inf), sin(Inf))
c(log(Inf), log(Inf, base = Inf))
c(NA + 1, NA * 5, NA + Inf)
x <- c(0, Inf, -Inf, NaN, NA)
is.finite(x)
is.infinite(x)
is.nan(x)
is.na(x)
(x <- 1:10 >= 5)
(y <- 1:10 %% 2 == 0)
x & y
x | y
x <- c(TRUE, FALSE, NA) #the three logical values
xy <- expand.grid(x = x, y = x) #get all combinations of x and y
within( #make the next assignments within xy
xy,
{
and <- x & y
or <- x | y
not.y <- !y
not.x <- !x
}
)
class(sqrt(1:10))
class(3 + 1i) #"i" creates imaginary components of complex numbers
class(1) #although this is a whole number, it has class numeric
class(1L) #add a suffix of "L" to make the number an integer
class(0.5:4.5) #the colon operator returns a value that is numeric...
class(1:5) #unless all its values are whole numbers
class(c("she", "sells", "seashells", "on", "the", "sea", "shore"))
(gender <- factor(c("male", "female", "female", "male", "female")))
levels(gender)
nlevels(gender)
if(!is(x, "some_class"))
{
#some corrective measure
}
is.character("red lorry, yellow lorry")
is.logical(FALSE)
is.list(list(a = 1, b = 2))
ls(pattern = "^is", baseenv())
is.numeric(1)
is.numeric(1L)
is.integer(1)
is.integer(1L)
is.double(1)
is.double(1L)
x <- "123.456"
as(x, "numeric")
as.numeric(x)
y <- c(2, 12, 343, 34997) #See http://oeis.org/A192892
as.data.frame(y)
ulams_spiral <- c(1, 8, 23, 46, 77) #See http://oeis.org/A033951
for(i in ulams_spiral) print(i)
print(ulams_spiral)
seq.int(3, 12)
seq.int(3, 12, 2)
seq.int(0.1, 0.01, -0.01)
n <- 0
1:n
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
poincare <- c(1, 0, 0, 0, 2, 0, 2, 0) #See http://oeis.org/A051629
length(poincare)
length(poincare) <- 3
poincare
c(apple = 1, banana = 2, "kiwi fruit" = 3, 4)
x <- 1:4
names(x) <- c("apple", "bananas", "kiwi fruit", "")
x
names(x)
x <- (1:5) ^ 2
x[c(1, 3, 5)]
x[c(-2, -4)]
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]
names(x) <- c("one", "four", "nine", "sixteen", "twenty five")
x[c("one", "nine", "twenty five")]
x[c(1, NA, 5)]
x[c(TRUE, FALSE, NA, FALSE, TRUE)]
rep(1:5, 3)
rep(1:5, each = 3)
rep(1:5, times = 1:5)
rep(1:5, length.out = 7)
rep.int(1:5, 3) # the same as rep(1:5, 3)
(three_d_array <- array(
1:24,
dim = c(4, 3, 2),
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei"),
c("un", "deux")
)
))
(a_matrix <- matrix(
1:12,
nrow = 4,  #ncol = 3 works the same
dimnames = list(
c("one", "two", "three", "four"),
c("ein", "zwei", "drei")
)
))
dim(a_matrix)
dim(a_matrix)
nrow(a_matrix)
ncol(a_matrix)
colnames(a_matrix)
rownames(a_matrix)
colnames(a_matrix)
dimnames(a_matrix)
rownames(a_matrix)
colnames(a_matrix)
dimnames(a_matrix)
a_matrix[1,]
a_matrix[,"zwei"]
a_matrix[1,]
a_matrix[,"zwei"]
a_matrix[,c("zwei","drei")]
a_matrix[,c("zwei")]
a_matrix[1,]
a_matrix[,"zwei"]
a_matrix[,c("zwei","drei")]
normalize(c(1, 3, 6, 10, NA))
an_environment <- new.env()
an_environment[["pythag"]] <- c(12, 15, 20, 21) #See http://oeis.org/A156683
an_environment$root <- polyroot(c(6, -5, 1))
assign(
"moonday",
weekdays(as.Date("1966/05/01")),
an_environment
)
ls(envir = an_environment)
ls.str(envir = an_environment)
exists("pythag", an_environment)
#Convert to list
(a_list <- as.list(an_environment))
as.environment(a_list)
list2env(a_list)
nested_environment <- new.env(parent = an_environment)
exists("pythag", nested_environment)
exists("pythag", nested_environment, inherits = FALSE)
non_stormers <<- c(3, 7, 8, 13, 17, 18, 21) #See http://oeis.org/A002312
get("non_stormers", envir = globalenv())
head(ls(envir = baseenv()), 20)
rt
stats_env <- new.env()
t_dist <- rt(200,1)
assign(
"t-dist-ex",
t_dist,
stats_env
)
options(scipen=999)
hypotenuse <- function(x, y){
# format(sqrt(x ^ 2 + y ^ 2), scientific = FALSE)
sqrt(x ^ 2 + y ^ 2)
}
hypotenuse(10,20)
hypo_large <- function(x,y){
max_xy = max(abs(x),abs(y))
min_xy = min(abs(x),abs(y))
r = min_xy / max_xy
# format(max_xy * sqrt(1+r^2),scientific = FALSE)
max_xy * sqrt(1+r^2)
}
hypo_large(10,20)
start_time <- Sys.time()
system.time({hypotenuse(12839081902859018902809189658908690849062830946802934860928309468902384068,1923091029309120390192309851894534534534537898643120591)})
hypotenuse(12839081902859018902809189658908690849062830946802934860928309468902384068,1923091029309120390192309851894534534534537898643120591)
end_time <- Sys.time()
end_time - start_time
start_time <- Sys.time()
system.time({hypo_large(12839081902859018902809189658908690849062830946802934860928309468902384068,1923091029309120390192309851894534534534537898643120591)})
hypotenuse(12839081902859018902809189658908690849062830946802934860928309468902384068,1923091029309120390192309851894534534534537898643120591)
end_time <- Sys.time()
end_time - start_time
normalize <- function(x, m = mean(x), s = sd(x)){
(x - m) / s
}
normalized <- normalize(c(1, 3, 6, 10, 15))
mean(normalized) #almost 0!
sd(normalized)
normalize(c(1, 3, 6, 10, NA))
normalize <- function(x, m = mean(x, na.rm = na.rm),
s = sd(x, na.rm = na.rm), na.rm = FALSE){
(x - m) / s
}
normalize(c(1, 3, 6, 10, NA))
normalize(c(1, 3, 6, 10, NA), na.rm = TRUE)
normalize <- function(x, m = mean(x, ...), s = sd(x, ...), ...){
(x - m) / s
}
normalize(c(1, 3, 6, 10, NA))
normalize(c(1, 3, 6, 10, NA), na.rm = TRUE)
do.call(hypotenuse, list(x = 3, y = 4))
do.call(hypotenuse, list(x = 3, y = 4)) # This is the same as hypotenuse(3,4)
dfr1 <- data.frame(x = 1:5, y = rt(5, 1))
dfr2 <- data.frame(x = 6:10, y = rf(5, 1, 1))
dfr3 <- data.frame(x = 11:15, y = rbeta(5, 1, 1))
do.call(rbind, list(dfr1, dfr2, dfr3)) #same as rbind(dfr1, dfr2, dfr3)
x_plus_y <- function(x, y) x + y
do.call(x_plus_y, list(1:5, 5:1))
#is the same as
do.call(function(x, y) x + y, list(1:5, 5:1))
(emp_cum_dist_fn <- ecdf(rnorm(50)))
is.function(emp_cum_dist_fn)
plot(emp_cum_dist_fn)
f <- function(x)
{
y <- 1
g <- function(x)
{
(x + y) / 2 #y is used, but is not a formal argument of g
}
g(x)
}
f(sqrt(5)) #It works! y is magically found in the environment of f
h2 <- function(x)
{
if(runif(1) > 0.5) y <- 12
x * y
}
h2 <- function(x)
{
if(runif(1) > 0.5) y <- 12
x * y
}
replicate(10,h(9))
h2 <- function(x)
{
if(runif(1) > 0.5) y <- 12
x * y
}
replicate(10,h2(9))
y < 19
y <- 19
h2 <- function(x)
{
if(runif(1) > 0.5) y <- 12
x * y
}
replicate(10, h2(9))
paste(c("red", "yellow"), "lorry")
paste(c("red", "yellow"), "lorry", sep = "-")
paste(c("red", "yellow"), "lorry", collapse = ", ")
paste0(c("red", "yellow"), "lorry")
c(
"You should use double quotes most of the time",
'Single quotes are better for including " inside the string'
)
x <- (1:15) ^ 2
toString(x)
toString(x, width = 40)
x <- c(
"I", "saw", "a", "saw", "that", "could", "out",
"saw", "any", "other", "saw", "I", "ever", "saw"
)
y <- noquote(x)
x
y
pow <- 1:6
(powers_of_e <- exp(pow))
formatC(powers_of_e)
formatC(powers_of_e, digits = 3) #3 sig figs
formatC(powers_of_e, digits = 3, width = 10) #preceding spaces
pow <- 1:6
(powers_of_e <- exp(pow))
formatC(powers_of_e)
formatC(powers_of_e, digits = 3) #3 sig figs
formatC(powers_of_e, digits = 3, width = 10) #preceding spaces
formatC(powers_of_e, digits = 3, format = "e") #scientific formatting
formatC(powers_of_e, digits = 3, flag = "+") #precede +ve values with +
sprintf("%s %d = %f", "Euler's constant to the power", pow, powers_of_e)
sprintf("To three decimal places, e ^ %d = %.3f", pow, powers_of_e)
sprintf("In scientific notation, e ^ %d = %e", pow, powers_of_e)
sprintf("%s %d = %f", "Euler's constant to the power", pow, powers_of_e)
sprintf("To three decimal places, e ^ %d = %.3f", pow, powers_of_e)
sprintf("In scientific notation, e ^ %d = %e", pow, powers_of_e)
formatC(powers_of_e, digits = 3, width = 10) #preceding spaces
pow <- -2:6
(powers_of_e <- exp(pow))
formatC(powers_of_e)
formatC(powers_of_e, digits = 3) #3 sig figs
formatC(powers_of_e, digits = 3, width = 10) #preceding spaces
formatC(powers_of_e, digits = 3, format = "e") #scientific formatting
formatC(powers_of_e, digits = 3, flag = "+") #precede +ve values with +
sprintf("%s %d = %f", "Euler's constant to the power", pow, powers_of_e)
sprintf("To three decimal places, e ^ %d = %.3f", pow, powers_of_e)
sprintf("In scientific notation, e ^ %d = %e", pow, powers_of_e)
format(powers_of_e)
format(powers_of_e,digits = 4) # this corrects up to 4 significant digits
format(powers_of_e,digits = 4, trim=TRUE) # this removes all leading zeros
format(powers_of_e,digits = 4, scientific = TRUE)
format(powers_of_e)
format(powers_of_e,digits = 4) # this corrects up to 4 significant digits
format(powers_of_e,digits = 4, trim=TRUE) # this removes all leading zeros
format(powers_of_e,digits = 4, scientific = TRUE)
(heights <- data.frame(
height_cm = c(153, 181, 150, 172, 165, 149, 174, 169, 198, 163),
gender = c("female", "male", "female", "male", "male",
"female", "female", "male", "male", "female")
))
(heights <- data.frame(
height_cm = c(153, 181, 150, 172, 165, 149, 174, 169, 198, 163),
gender = c("female", "male", "female", "male", "male",
"female", "female", "male", "male", "female")
))
class(heights$gender)
